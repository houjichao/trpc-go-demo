内存管理
内存管理主要包括两个动作：分配与释放。逃逸分析就是服务于内存分配。

栈
在Go中，栈的内存是由编译器自动进行分配和释放，栈区往往存储着函数参数、局部变量和调用函数帧，
它们随着函数的创建而分配，函数的退出而销毁。

一个goroutine对应一个栈，栈是调用栈（call stack）的简称。一个栈通常又包含了许多栈帧（stack frame），
它描述的是函数之间的调用关系，每一帧对应一个尚未返回的函数调用，它本身也是以栈形式存放数据。

堆
与栈不同的是，应用程序在运行时只会存在一个堆。
我们可以简单理解为：我们用GO语言开发过程中，要考虑的内存管理只是针对堆内存而言的。
程序在运行期间可以主动从堆上申请内存，这些内存通过Go的内存分配器分配，并由垃圾收集器回收。

堆和栈的对比
加锁
栈不需要加锁：栈是每个goroutine独有的，这就意味着栈上的内存操作是不需要加锁的。

堆有时需要加锁：堆上的内存，有时需要加锁防止多线程冲突

延伸知识点：为什么堆上的内存有时需要加锁？而不是一直需要加锁呢？
因为Go的内存分配策略学习了TCMalloc的线程缓存思想，他为每个处理器P分配了一个mcache，从mcache分配内存也是无锁的

性能
栈内存管理 性能好：栈上的内存，它的分配与释放非常高效的。简单地说，它只需要两个CPU指令：一个是分配入栈，另外一个是栈内释放。只需要借助于栈相关寄存器即可完成。
堆内存管理 性能差：对于程序堆上的内存回收，还需要通过标记清除阶段，例如Go采用的三色标记法。
缓存策略
栈缓存性能更好
堆缓存性能较差
原因是：栈内存能更好地利用CPU的缓存策略，因为栈空间相较于堆来说是更连续的。

逃逸分析
上面说了这么多堆和栈的知识点，目的是为了让大家更好的理解逃逸分析。

正如上面讲的，相比于把内存分配到堆中，分配到栈中优势更明显。

Go语言也是这么做的：Go编译器会尽可能将变量分配到到栈上。

但是，当编译器无法证明函数返回的变量有没有被引用时，编译器就必须在堆上分配该变量，以此避免悬挂指针（dangling pointer）的问题。

另外，如果局部变量占用内存非常大，也会将其分配在堆上。

Go是如何确定内存是分配到栈上还是堆上的呢？

答案就是：逃逸分析。

编译器通过逃逸分析技术去选择堆或者栈，逃逸分析的基本思想如下：检查变量的生命周期是否是完全可知的，如果通过检查，则在栈上分配。否则，就是所谓的逃逸，必须在堆上进行分配。

逃逸分析原则
Go语言虽然没有明确说明逃逸分析原则，但是有以下几点准则，是可以参考的。
1.不同于JAVA JVM的运行时逃逸分析，Go的逃逸分析是在编译期完成的：编译期无法确定的参数类型必定放到堆中；
2.如果变量在函数外部存在引用，则必定放在堆中；
3.如果变量占用内存较大时，则优先放到堆中；
4.如果变量在函数外部没有引用，则优先放到栈中；

思考题
好了，我们举了4个逃逸分析的经典案例，相信聪明的你已经理解了逃逸分析的作用和发生逃逸的场景。
我们来想一下，在理解逃逸分析的原理之后，在开发的过程中如何更好的编码，进而提高程序的效率，更好的利用内存呢？

如何实践？
理解逃逸分析一定能帮助我们写出更好的程序。知道变量分配在栈堆之上的差别后，我们就要尽量写出分配在栈上的代码。因为堆上的变量变少后，可以减轻内存分配的开销，减小GC的压力，提高程序的运行速度。
但是我们也要有过犹不及的指导思想。
我认为没有一成不变的开发模式，我们一定是在不断的需求变化，业务变化中求得平衡的：

举个栗子
举个日常开发中函数传参例子：
有些场景下我们不应该传递结构体指针，而应该直接传递结构体。
为什么会这样呢？虽然直接传递结构体需要值拷贝，但是这是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内存少的多。
当然这种做法不是绝对的，要根据场景去分析：
如果结构体较大，传递结构体指针更合适，因为指针类型相比值类型能节省大量的内存空间
如果结构体较小，传递结构体更适合，因为在栈上分配内存，可以有效减少GC压力